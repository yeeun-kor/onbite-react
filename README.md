# React Counter - App 라이프사이클로 관리하기 (미니프로젝트 🕰️ 2025.05.22)

# useEffect()사용하기

`  useEffect(() => {}, []);`

1. 첫번째 인수 : 콜백함수
2. 두번째 인수 : 배열

## useEffect()동작 순서

1. 배열의 값이 바뀌면
2. sideEffect 효과로서, 콜백함수를 실행시킴

### 예시

1. 배열에 변화되는 값 (state) 을 넣으면, state상태가 바뀔 때마다, 콜백함수가 실행
2. 🤔배열이 바뀔때 마다 콜백함수가 실행되는거니, `배열`에 의존하게 됨.
   > useEffect() 사용되는 배열을 '의존성 배열 ( dependency array = deps )`이라고 부름.

## 의존성배열 (deps)

- deps는 값을 여러개 넣어도 된다.

---

# 라이프사이클 제어하기 (useEffect()로 제어)

1. 마운트 : 생성
2. 업데이트 : 변화,리랜더링
3. 언마운트 : 죽음

## 1. 마운트 제어하기

`  useEffect(() => {}, []);`

- deps를 빈배열로 설정하면, 변화되는 값이 없기 때문에 ! 이 App컴포넌트가 `mount`될 때만 실행되고, 그 이후에는 실행X
- 그래서 컴포넌트가 `mount`되었을때, 최초로 1번만 실행하고 싶은 코드가 있다면? 👉🏻 `deps` 로 빈배열을 반환 하도록.

## 2. 업데이트 제어하기

`  useEffect(() => {  });`

- deps를 아예 처음부터 생략하면, App컴포넌트가 `리랜더링 `될때마다 호출이 된다.
- 마운트의 빈배열은 , 변화가 있을때에만 호출 -> 첫 마운트 될때에만 호출인거고
- 업데이트는 `함수컴포넌트 자체가 리랜더링` 될때 호출이 됨.
  > 처음 mount될때엔 왜 update 도 출력이 되는 걸까?
  - mount도 최초 랜더링에 포함이 된다.
  - 그래서 updating 로그가 최초 마운트를 제외하고 **상태/props 변경 시에만 출력되길** 원한다면, 의존성 배열에 특정 상태를 추가

### mount체크하는 useRef 이용하기

1. 현재 컴포넌트가 `마운트`되었는지 확인하는 `useRef()`객체 생성하기

- `const isMount = useRef(false);`
- useRef의 초기값은 마운트 되기 전이니깐, "false"설정

2. 콜백함수에 조건문 추가

- `  useEffect(() => {
  if (!isMount.current) {
    isMount.current = true;
    return;
  }
  console.log("updating");
});`
- if문 : useRef객체값이 false 는 마운트 되지 않았다는 뜻 . 즉, 초기 랜더링이 되지 않은상태
- if문 결과 : 초기랜더링이 되지 않았으면, true로 바꾸어 return으로 if문 빠져나오기 -> 그로인해 console의 업데이트 ㅏㅄ이 호출되지 않음

## 3. unmount제어하기

- `  useEffect(() => {
return ()=>{}}, []);` 설정하되, 콜백함수의 return부분에 콜백함수 추가하기
- 이 return의 콜백함수는 "클린업함수"라고 함
- 클린업함수는 unmount시 실행된다.
- 그래서 이 클린업함수를 활용하여 unmount 관리해주면 된다.

---
